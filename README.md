# Simplicity

Simplicity is a simple abstraction around URLSession that makes it easy to make type safe HTTP requests.

It was inspired by the Clients generated by swift-openapi-generator.
You can add middleware to perform operations before or after an outgoing request is executed.

## Usage

```swift
// First you create a type to represent a request to your endpoint
struct LoginRequest: HTTPRequest {
    struct RequestBody: Encodable & Sendable {
        var username: String
        var password: String
    }
    
    struct ResponseBody: Decodable & Sendable {
        var token: String
    }
    
    static let operationID: String = "LoginRequest"
    var path: String { "/login" }
    var httpMethod: Simplicity.HTTPMethod { .post }
    var headers: [String : String] { [:] }
    var queryItems: [URLQueryItem] { [] }
    var httpBody: RequestBody
    
    // No need to implement encodeURLRequest â€” by default, Simplicity encodes JSON bodies
    // and sets Content-Type: application/json (and Accept: application/json) when missing.
    // Override encodeURLRequest if you need a different encoding strategy.
    
    // add custom logic to decode your response here, or you can use the default protocol implementation
    func decodeResponseData(_ data: Data) throws -> ResponseBody {
        try JSONDecoder().decode(ResponseBody.self, from: data)
    }
}

// next initialize a client.
var client = HTTPClient(urlSession: .shared, baseURL: "https://myapi.com", middlewares: [LoggingMiddleware()])

// Finally, send your request
let response = try await client.send(request: LoginRequest(username: "JohnDoe1234", password: "P@ssword123"))
print(response.token)
```

## Middleware

Setting up middleware is also quite simple

```swift
struct LoggingMiddleware: Middleware {
    private let logger: Logger
    
    init(logger: Logger) {
        self.logger = logger
    }
    
    func intercept<Request: HTTPRequest>(
        request: Request,
        baseURL: URL,
        next: nonisolated(nonsending) @Sendable (
            _ request: Request,
            _ baseURL: URL
        ) async throws -> HTTPResponse<Request.ResponseBody>
    ) async throws -> HTTPResponse<Request.ResponseBody> {
        let urlRequest = try request.encodeURLRequest(baseURL: baseURL)
    
        // log request information
        logger.info("""
        REQUEST:
        \(request.httpMethod) \(baseURL.appending(path: request.path).appending(queryItems: request.queryItems))
        Headers: \(request.allHTTPHeaderFields)
        Query: \(request.query)
        Request Body: \(String(data: request.httpBody!, encoding: .utf8)!)
        """)
        
        // continue on to execute the request
        let response = try await next(request, baseURL, operationID)
        
        // log response
        logger.info("""
        RESPONSE:
        HTTP Status: \(response.statusCode)
        Headers: \(response.headers)
        Response Body: \(String(data: data, encoding: .utf8)!)
        """)
    }
}
```

## Caching

The provided URLSessionHTTPClient leverages standard URLCache to do its caching. 
To implement a cache, you would need to provide your own URLSession with configuration as opposed to using the default URLSession implementation.

See [URLCache](https://developer.apple.com/documentation/foundation/urlcache) for details

Custom HTTPClient implementations should implement caching policies as per the `CachePolicy` enum provided. 
