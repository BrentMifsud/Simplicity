# Simplicity

Simplicity is a simple abstraction around URLSession that makes it easy to make type safe HTTP requests.

It was inspired by the Clients generated by swift-openapi-generator.
You can add middleware to perform operations before or after an outgoing request is executed.

## Usage

```swift
import Foundation
import Simplicity

// Define a typed request for your endpoint
struct LoginRequest: HTTPRequest {
    // Request body type
    struct Body: Encodable, Sendable {
        var username: String
        var password: String
    }

    // Response body types
    struct Success: Decodable, Sendable { var token: String }
    struct Failure: Decodable, Sendable { var error: String }

    // Associate the types with the HTTPRequest protocol
    // All of these types can work with `Never` if you wish to omit them.
    typealias RequestBody = Body
    typealias SuccessResponseBody = Success
    typealias FailureResponseBody = Failure

    // Endpoint metadata
    static var operationID: String { "login" }
    var path: String { "/login" }
    var httpMethod: HTTPMethod { .post }
    var headers: [String : String] { ["Accept": "application/json"] }
    var queryItems: [URLQueryItem] { [] }

    // The actual body instance to send
    var httpBody: Body

    // Defaults provided by the library, but can be implmented if desired:
    // - createURLRequest(baseURL:) builds a URLRequest and uses encodeHTTPBody().
    // - encodeHTTPBody() JSON-encodes `httpBody` when present; returns nil for Never/Never?.
    // - decodeSuccessResponseData(_:) and decodeFailureResponseData(_:) decode JSON.
}

// Initialize a client and send the request
let client = URLSessionHTTPClient(baseURL: URL(string: "https://myapi.com")!, middlewares: [])
let response = try await client.send(request: LoginRequest(httpBody: .init(username: "JohnDoe1234", password: "P@ssword123")))

// Decode the typed success body or failure body on demand
if response.statusCode.isSuccess {
    let model = try response.decodeSuccessBody()
    print(model.token)
} else {
    let failure = try response.decodeFailureBody()
    print(failure.error)
}
```

## Middleware

Setting up middleware is also quite simple. Middleware receive and return lightweight tuples instead of generic request/response types. The `request` you get is:

- `httpMethod: HTTPMethod`
- `baseURL: URL`
- `headers: [String: String]`
- `httpBody: Data?`

You can mutate any of these fields before calling `next`.

```swift
struct LoggingMiddleware: Middleware {
    private let logger: Logger

    init(logger: Logger) {
        self.logger = logger
    }

    func intercept(
        request: Middleware.Request,
        next: nonisolated(nonsending) @Sendable (Middleware.Request) async throws -> Middleware.Response
    ) async throws -> Middleware.Response {
        // Log request information
        let bodyPreview = request.httpBody.flatMap { String(data: $0, encoding: .utf8) } ?? "<none>"
        logger.info("""
        REQUEST:
        \(request.httpMethod) \(request.baseURL)
        Headers: \(request.headers)
        Body: \(bodyPreview)
        """)

        try Task.checkCancellation()

        // Continue on to execute the request (or further middleware)
        let response = try await next(request)

        // Log response
        let responseBodyPreview = String(decoding: response.httpBody, as: UTF8.self)
        logger.info("""
        RESPONSE:
        HTTP Status: \(response.statusCode)
        URL: \(response.url.absoluteString)
        Headers: \(response.headers)
        Body: \(responseBodyPreview)
        """)

        return response
    }
}
```

## Caching

The provided URLSessionHTTPClient leverages standard URLCache to do its caching. 
To implement a cache, you would need to provide your own URLSession with configuration as opposed to using the default URLSession implementation.

See [URLCache](https://developer.apple.com/documentation/foundation/urlcache) for details

Custom HTTPClient implementations should implement caching policies as per the `CachePolicy` enum provided. 
