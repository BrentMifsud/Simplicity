# Simplicity

Simplicity is a simple abstraction around URLSession that makes it easy to make type safe HTTP requests.

It was inspired by the Clients generated by swift-openapi-generator.
You can add middleware to perform operations before or after an outgoing request is executed.

## Usage

```swift
// First you create a type to represent a request to your endpoint
struct LoginRequest: HTTPRequest {
    struct RequestBody: Encodable & Sendable {
        var username: String
        var password: String
    }
    
    struct ResponseBody: Decodable & Sendable {
        var token: String
    }
    
    static let operationID: String = "LoginRequest"
    var path: String { "/login" }
    var httpMethod: Simplicity.HTTPMethod { .post }
    var headers: [String : String] { [:] }
    var queryItems: [URLQueryItem] { [] }
    var httpBody: RequestBody
    
    // No need to implement encodeURLRequest â€” by default, Simplicity encodes JSON bodies
    // and sets Content-Type: application/json (and Accept: application/json) when missing.
    // Override encodeURLRequest if you need a different encoding strategy.
    
    // add custom logic to decode your response here, or you can use the default protocol implementation
    func decodeResponseData(_ data: Data) throws -> ResponseBody {
        try JSONDecoder().decode(ResponseBody.self, from: data)
    }
}

// next initialize a client.
var client = HTTPClient(urlSession: .shared, baseURL: "https://myapi.com", middlewares: [LoggingMiddleware()])

// Finally, send your request
let response = try await client.send(request: LoginRequest(username: "JohnDoe1234", password: "P@ssword123"))
print(response.token)
```

## Middleware

Setting up middleware is also quite simple. Middleware receive and return lightweight tuples instead of generic request/response types. The `request` you get is:

- `httpMethod: HTTPMethod`
- `baseURL: URL`
- `headers: [String: String]`
- `httpBody: Data?`

You can mutate any of these fields before calling `next`.

```swift
struct LoggingMiddleware: Middleware {
    private let logger: Logger

    init(logger: Logger) {
        self.logger = logger
    }

    func intercept(
        request: Middleware.Request,
        next: nonisolated(nonsending) @Sendable (Middleware.Request) async throws -> Middleware.Response
    ) async throws -> Middleware.Response {
        // Log request information
        let bodyPreview = request.httpBody.flatMap { String(data: $0, encoding: .utf8) } ?? "<none>"
        logger.info("""
        REQUEST:
        \(request.httpMethod) \(request.baseURL)
        Headers: \(request.headers)
        Body: \(bodyPreview)
        """)

        try Task.checkCancellation()

        // Continue on to execute the request (or further middleware)
        let response = try await next(request)

        // Log response
        let responseBodyPreview = String(decoding: response.httpBody, as: UTF8.self)
        logger.info("""
        RESPONSE:
        HTTP Status: \(response.statusCode)
        URL: \(response.url.absoluteString)
        Headers: \(response.headers)
        Body: \(responseBodyPreview)
        """)

        return response
    }
}
```

## Caching

The provided URLSessionHTTPClient leverages standard URLCache to do its caching. 
To implement a cache, you would need to provide your own URLSession with configuration as opposed to using the default URLSession implementation.

See [URLCache](https://developer.apple.com/documentation/foundation/urlcache) for details

Custom HTTPClient implementations should implement caching policies as per the `CachePolicy` enum provided. 
